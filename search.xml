<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>lowcomote</title>
    <url>/Olivia_Lam.github.io/2022/10/11/lowcomote/</url>
    <content><![CDATA[<p>低代码开发的一个基金项目，15个方向探查笔记</p>
<span id="more"></span>

<h1 id="ESR-1-Scaling-Up-Citizen-Development-with-Recommender-Chatbots（使用推荐系统提高低代码开发人员体验）"><a href="#ESR-1-Scaling-Up-Citizen-Development-with-Recommender-Chatbots（使用推荐系统提高低代码开发人员体验）" class="headerlink" title="ESR 1: Scaling Up Citizen Development with Recommender Chatbots（使用推荐系统提高低代码开发人员体验）"></a>ESR 1: Scaling Up Citizen Development with Recommender Chatbots（使用推荐系统提高低代码开发人员体验）</h1><p>为了提高LCDP用户开发效率以及开发体验，在LCDP平台嵌入集成了推荐系统的聊天机器人，给开发者推荐下一步需要的项目。</p>
<p>看了挂出来的三篇文章，一篇是自动生成RS、一篇是RS应用在MDE、一篇是RS在MDE中作用的综述。第一篇讲的是通过DSL配置RS并生成、评估的过程，第二篇讲的是RS在LCDP中应用的架构，第三篇讲了一下RS在MDE中的作用，没细看。</p>
<blockquote>
<p>自动生成RS：<a href="https://olive-2019.github.io/Olivia_Lam.github.io/2022/10/01/RS/#more" title="自动生成RS">Automating the Synthesis of Recommender Systems for Modelling Languages</a></p>
<p>RS应用在MDE：<a href="https://olive-2019.github.io/Olivia_Lam.github.io/2022/10/08/RS3/">Towards automating the construction of recommender systems for low-code development platforms</a></p>
<p>RS在MDE中的综述：<a href="https://olive-2019.github.io/Olivia_Lam.github.io/2022/10/05/Engineering/#more">Recommender Systems in Model-Driven Engineering</a></p>
</blockquote>
<h1 id="ESR-2-Scalable-Cloud-Based-Heterogeneous-Modelling（基于云的可拓展异构）"><a href="#ESR-2-Scalable-Cloud-Based-Heterogeneous-Modelling（基于云的可拓展异构）" class="headerlink" title="ESR 2: Scalable Cloud-Based Heterogeneous Modelling（基于云的可拓展异构）"></a>ESR 2: Scalable Cloud-Based Heterogeneous Modelling（基于云的可拓展异构）</h1><p>目前没找到其它资料（没有具体的工作），只看了一下介绍，应该是优化LCDP编辑器的搭建。之前用的JavaScript技术过于底层，开发不友好。目标是建立基于工程语言原理（其实没读懂这个是啥？）的界面开发，大概就是配置一下就能生成界面的意思吧。</p>
<h1 id="ESR-3-Deploying-and-Scaling-Knowledge-Models-in-Data-Science"><a href="#ESR-3-Deploying-and-Scaling-Knowledge-Models-in-Data-Science" class="headerlink" title="ESR 3: Deploying and Scaling Knowledge Models in Data Science"></a>ESR 3: Deploying and Scaling Knowledge Models in Data Science</h1>]]></content>
      <categories>
        <category>基金项目</category>
      </categories>
      <tags>
        <tag>lowcomote</tag>
      </tags>
  </entry>
  <entry>
    <title>Towards a low-code solution for monitoring machine learning model performance</title>
    <url>/Olivia_Lam.github.io/2022/10/23/MonitoringMLPerformance/</url>
    <content><![CDATA[<p>机器学习模型部署后的漂移问题以及检测漂移的工具，并概述了低代码开发平台解决该问题的研究计划</p>
<span id="more"></span>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>ML模型由专家开发以后需要部署到生产环境中，部署的时候需要自动化工具。本文的目标是提出一个低代码架构，使专家可以监控ML模型性能。</p>
<p>文章对机器学习的工作流进行了综述以后，介绍了模型部署后可能发生的数据漂移和概念漂移。然后提出了低代码开发实现监控程序的三个研究方向，并说明了评价方法。最后介绍了一些机器学习自动化的工具。</p>
<h1 id="机器学习-工作流（workflow）"><a href="#机器学习-工作流（workflow）" class="headerlink" title="机器学习 工作流（workflow）"></a>机器学习 工作流（workflow）</h1><p><img src="https://github.com/Olive-2019/Lam-Blog-resource/blob/master/images/MDEforMLMonitor/MLworkflow.jpg?raw=true" alt="机器学习 工作流"></p>
<h2 id="数据准备-Data-Preparation"><a href="#数据准备-Data-Preparation" class="headerlink" title="数据准备 Data Preparation"></a>数据准备 Data Preparation</h2><p>检测输入是否符合规范（数据格式）</p>
<h2 id="模型构建-Model-Creation"><a href="#模型构建-Model-Creation" class="headerlink" title="模型构建 Model Creation"></a>模型构建 Model Creation</h2><p>记录不同的算法参数组合的结果，这部分讲的有点偏ML调参了，不过可以应用在RS的构建里。<br>另外，这里提到的openML可以用来做模型构建的工作。<a href="https://www.openml.org/">OpenML链接</a></p>
<blockquote>
<p>OpenML is an open platform for sharing datasets, algorithms, and experiments to learn how to learn better, together.</p>
</blockquote>
<h2 id="模型构建后动作-Post-Creation-Activities"><a href="#模型构建后动作-Post-Creation-Activities" class="headerlink" title="模型构建后动作 Post-Creation Activities"></a>模型构建后动作 Post-Creation Activities</h2><p>由于采样数据可能存在的误差和环境动态变化，模型部署后要进行性能监控。</p>
<h1 id="模型监控"><a href="#模型监控" class="headerlink" title="模型监控"></a>模型监控</h1><h2 id="数据漂移"><a href="#数据漂移" class="headerlink" title="数据漂移"></a>数据漂移</h2><p>数据漂移，也叫采样漂移，指部署后数据概率分布与学习集不同了。</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>可能原因的是采样机制、环境中未知因素随时间变化改变。</p>
<h3 id="后果"><a href="#后果" class="headerlink" title="后果"></a>后果</h3><p>数据偏移不一定导致输出错误，没有数据偏移也不一定能保证输出正确</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>可以直接通过检查输入来检测数据漂移，故可以用作模型表现下降的非间接指标</p>
<h2 id="概念漂移"><a href="#概念漂移" class="headerlink" title="概念漂移"></a>概念漂移</h2><p>概念漂移，指输入-输出的映射发生了改变。</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>可以是真实的也可能是虚拟的<br>真实：映射由于未知因素（隐藏上下文）发生了改变<br>虚拟：在受检测领域中没有任何改变，只是由于其它原因观测到了这一现象（如有偏采样）</p>
<h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><p>概念偏移不能只依靠检测模型输出检测，需要更多的信息去检测每个输入的输出是否正确</p>
<h2 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h2><p>特征：等待持续时长，实际服务时长</p>
<p>输出：电话中心的客服表现（positive or negative）</p>
<p>假设上述特征均~N(10,3)</p>
<!-- 原始分布.jpg -->
<p><img src="https://github.com/Olive-2019/Lam-Blog-resource/blob/master/images/MDEforMLMonitor/%E5%8E%9F%E5%A7%8B%E5%88%86%E5%B8%83.jpg?raw=true" alt="原始分布"></p>
<p>模型：总时长小于20则为positive</p>
<p>模型部署后可能存在四种场景</p>
<h3 id="无漂移"><a href="#无漂移" class="headerlink" title="无漂移"></a>无漂移</h3><p>理想状态，输入的数据分布不改变，模型也一直符合现实状况</p>
<h3 id="数据漂移-1"><a href="#数据漂移-1" class="headerlink" title="数据漂移"></a>数据漂移</h3><!-- 数据漂移.jpg -->
<p><img src="https://github.com/Olive-2019/Lam-Blog-resource/blob/master/images/MDEforMLMonitor/%E6%95%B0%E6%8D%AE%E6%BC%82%E7%A7%BB.jpg?raw=true" alt="数据漂移"></p>
<p>例如某个客服没上班，等待时长变长，但是用户并不会因此愿意等待更长时间。<br>这种数据漂移并没有导致输出错误</p>
<h3 id="概念漂移-1"><a href="#概念漂移-1" class="headerlink" title="概念漂移"></a>概念漂移</h3><!-- 概念漂移.jpg -->

<p><img src="https://github.com/Olive-2019/Lam-Blog-resource/blob/master/images/MDEforMLMonitor/%E6%A6%82%E5%BF%B5%E6%BC%82%E7%A7%BB.jpg?raw=true" alt="概念漂移"></p>
<p>模型不再符合现实情况，但是数据分布不发生改变，输出存在错误。如用户愿意等的更长，则现实模型划分线应该上移。<br>这种情况下，模型需要重新学习新数据。</p>
<h3 id="两种漂移并存"><a href="#两种漂移并存" class="headerlink" title="两种漂移并存"></a>两种漂移并存</h3><!-- 有偏采样.jpg -->

<p><img src="https://github.com/Olive-2019/Lam-Blog-resource/blob/master/images/MDEforMLMonitor/%E6%9C%89%E5%81%8F%E9%87%87%E6%A0%B7.jpg?raw=true" alt="有偏采样"></p>
<!-- 两种漂移.jpg -->

<p><img src="https://github.com/Olive-2019/Lam-Blog-resource/blob/master/images/MDEforMLMonitor/%E4%B8%A4%E7%A7%8D%E6%BC%82%E7%A7%BB%E5%B9%B6%E5%AD%98.jpg?raw=true" alt="两种漂移"></p>
<p>有偏采样发生时，输入数据的分布自然与学习集不同了。同时，由于学习集的分布与真实输入不同，训练出来的模型自然不能用于真实输入。但是我们会以为观察到数据漂移和真实概念漂移。目前区分真实和虚假的概念漂移仍是一个挑战。</p>
<h1 id="研究方向"><a href="#研究方向" class="headerlink" title="研究方向"></a>研究方向</h1><p>希望开发一个低代码的解决方案将现代计算架构带来的复杂性抽象化，包括DSL和参考实现。允许用户只需要配置模型监控方案，不必关注具体细节。将模型监控的任务分成三大类，分别是，数据捕捉、算法执行、响应漂移。</p>
<h2 id="数据捕捉"><a href="#数据捕捉" class="headerlink" title="数据捕捉"></a>数据捕捉</h2><p>为了检测概念漂移，需要存储模型输出并与反馈进行对比。</p>
<p>在客服中心的例子中，为了获取并存储这些数据，建立了反向代理服务器（reverse proxy server）。反向代理服务器可以接收所有的推理请求并转发到模型服务架构中，获取模型输出并返回到客户端。另外，反向代理服务器可以将这些数据和必须的元数据持久化到数据库当中。</p>
<!-- 数据捕捉.jpg -->

<p><img src="https://github.com/Olive-2019/Lam-Blog-resource/blob/master/images/MDEforMLMonitor/%E6%95%B0%E6%8D%AE%E6%8D%95%E6%8D%89.jpg?raw=true" alt="数据捕捉"></p>
<p>反向代理服务器的优点：</p>
<ul>
<li>模型服务器不必发生改变</li>
<li>适用于各种模型服务器。</li>
</ul>
<p>为了标记不同的交互，需要有唯一ID。<br>在这个任务中建立低代码开发平台的两个重要的机制：</p>
<ul>
<li>收集模型的输入输出</li>
<li>收集反馈</li>
</ul>
<p>收集反馈的困难在于收集方式取决于模型，例如推荐系统的反馈收集只需要记录一下是否点击，而图片分类器的反馈收集必须要人工介入。</p>
<h2 id="算法执行"><a href="#算法执行" class="headerlink" title="算法执行"></a>算法执行</h2><p>检测算法的性能是非常重要的<br>希望能使用DSL来描述漂移检测算法，然后生成适用于不同框架的算法</p>
<h2 id="响应漂移"><a href="#响应漂移" class="headerlink" title="响应漂移"></a>响应漂移</h2><p>简单但重要，方法是多样的，可以包含以下两种</p>
<ul>
<li>检测到漂移时简单地发送email</li>
<li>自动触发重新训练模型的流程<br>前者多用于数据漂移，后者多用于概念漂移。</li>
</ul>
<h2 id="评价计划"><a href="#评价计划" class="headerlink" title="评价计划"></a>评价计划</h2><p>需要通过参考实施评估提出的方案。</p>
<ul>
<li>参考实施需要满足的需求：</li>
<li>和不同模型服务器之间兼容的能力</li>
<li>截取模型输入输出时不会有太大的性能损失</li>
<li>计算和存储大数据的能力</li>
<li>足够灵活，允许学者配置不同检测算法</li>
<li>整合不同的反馈方式</li>
</ul>
<h1 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h1><p>现在有很多可以简化ML workflow的工具，但是大都私用，以下介绍公开可用的几个</p>
<h2 id="MLflow"><a href="#MLflow" class="headerlink" title="MLflow"></a>MLflow</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li>元数据追踪</li>
<li>提高实验可复现性</li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>容易和流行的机器学习框架结合使用</li>
<li>有直观的UI。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>不是一个端到端的工具，并没有覆盖所有的workflow，还有数据准备和模型监控没有覆盖</li>
</ul>
<h2 id="Tensorflow-extended"><a href="#Tensorflow-extended" class="headerlink" title="Tensorflow extended"></a>Tensorflow extended</h2><p>TFX是一个Google开发的端到端的工具。</p>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>支持TF的生态系统、一个任务的输出就是下一个任务的输入，减少了人工工作。</p>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>仅支持tf core为模型训练步骤使用的框架</li>
<li>模型监控方面只支持检测数据漂移，仅针对分类特征，只提供一种距离度量</li>
</ul>
<h2 id="alibi-detect"><a href="#alibi-detect" class="headerlink" title="alibi-detect"></a>alibi-detect</h2><p>开源</p>
<p>提供的检测算法</p>
<ul>
<li>数据漂移</li>
<li>异常值</li>
<li>对抗样本</li>
</ul>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>lowcomote</tag>
        <tag>ML</tag>
        <tag>monitoring</tag>
        <tag>data draft</tag>
        <tag>concept draft</tag>
      </tags>
  </entry>
  <entry>
    <title>Beamer食用指南</title>
    <url>/Olivia_Lam.github.io/2022/10/22/beamer/</url>
    <content><![CDATA[<p>一个LaTeX的文档类型，可替代PowerPoint</p>
<span id="more"></span>

<h1 id="为什么要用Beamer"><a href="#为什么要用Beamer" class="headerlink" title="为什么要用Beamer"></a>为什么要用Beamer</h1><p>我们第一次做PPT的时候总是想去尝试不同的动画效果，但是逐渐地，我们开始回归自然，追求简洁美，更专注内容。这时放弃PowerPoint选择Beamer将会是一个非常好的选择。以下给出几条使用理由，只要踩中了一条，欢迎使用本教程。</p>
<ul>
<li>对数学公式的完美支持（LaTeX对公式的支持不必多说）</li>
<li>关注内容，不必关注排版</li>
<li>自动的目录索引和跳转</li>
<li>配合GitHub使用，实现版本管理</li>
<li>不费力气地做出看起来更学术，更专业的幻灯片</li>
</ul>
<p>但是如果你具有以下特征，beamer可能也不是那么适合你</p>
<ul>
<li>极端厌恶代码：beamer还是有点代码，不过其实挺少的，有点像HTML</li>
<li>对幻灯片动画有高度追求：beamer相对来说走的是简洁风</li>
</ul>
<h1 id="本教程要求的用户基础"><a href="#本教程要求的用户基础" class="headerlink" title="本教程要求的用户基础"></a>本教程要求的用户基础</h1><p>本教程面向两种人群，前者是有LaTeX基础的人群，主要介绍如何修改模板配置文件使之成为自己想要的样子；后者是完全没有LaTeX基础的人群，主要介绍如何从0开始使用Beamer。</p>
<h1 id="从0开始拥有Beamer"><a href="#从0开始拥有Beamer" class="headerlink" title="从0开始拥有Beamer"></a>从0开始拥有Beamer</h1><p>已有LaTeX基础人群请跳过本段</p>
<h2 id="LaTeX安装与使用"><a href="#LaTeX安装与使用" class="headerlink" title="LaTeX安装与使用"></a>LaTeX安装与使用</h2><p>LaTeX的安装教程网上比较多，此处不再赘述，随便找一个教程跟着走下来就行了</p>
<p>使用方面推荐搭配VSCode和相关插件使用，原生的编辑器实在是过于原始了</p>
<h2 id="Beamer基本LaTeX结构"><a href="#Beamer基本LaTeX结构" class="headerlink" title="Beamer基本LaTeX结构"></a>Beamer基本LaTeX结构</h2><p>LaTeX的语法跟HTML挺神似的，应该都能看懂</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\documentclass&#123;beamer&#125;</span><br><span class="line">\usepackage&#123;包的名称&#125;</span><br><span class="line">\usetheme&#123;主题名称&#125;</span><br><span class="line">\usecolortheme&#123;颜色主题名称&#125;</span><br><span class="line">\usefonttheme&#123;字体主题名称&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">标题、作者、单位和日期等信息</span><br><span class="line">\begin&#123;frame&#125; </span><br><span class="line">幻灯片内容</span><br><span class="line">\end&#123;frame&#125;</span><br><span class="line">......</span><br><span class="line">\begin&#123;frame&#125; </span><br><span class="line">幻灯片内容</span><br><span class="line">\end&#123;frame&#125;</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h2><p>当想要给幻灯片做分段的时候，可以使用下列代码做多级标题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\section&#123;一级标题&#125;</span><br><span class="line">\subsection&#123;二级标题&#125;</span><br><span class="line">\subsubsection&#123;三级标题&#125;</span><br></pre></td></tr></table></figure>

<p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\section&#123;摸鱼学导论第一章&#125;</span><br><span class="line">\subsection&#123;第一节：什么是摸鱼&#125;</span><br><span class="line">\subsubsection&#123;第一小节：摸鱼的快乐&#125;</span><br><span class="line">\begin&#123;frame&#125; </span><br><span class="line">幻灯片内容</span><br><span class="line">\end&#123;frame&#125;</span><br><span class="line">\subsection&#123;第二节：如何摸鱼&#125;</span><br><span class="line">\begin&#123;frame&#125; </span><br><span class="line">幻灯片内容</span><br><span class="line">\end&#123;frame&#125;</span><br></pre></td></tr></table></figure>

<h2 id="幻灯片内容"><a href="#幻灯片内容" class="headerlink" title="幻灯片内容"></a>幻灯片内容</h2><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\begin&#123;frame&#125;&#123;标题&#125;</span><br><span class="line">幻灯片内容</span><br><span class="line">\end&#123;frame&#125;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\begin&#123;frame&#125;&#123;快乐摸鱼&#125;</span><br><span class="line">如何让自己的摸鱼更快乐呢？</span><br><span class="line">第一个级别是接受摸鱼。第二个级别是享受摸鱼。第三个级别是高水平摸鱼，成为一名摸鱼大师。</span><br><span class="line">\end&#123;frame&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用结构"><a href="#常用结构" class="headerlink" title="常用结构"></a>常用结构</h3><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><h5 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\begin&#123;itemize&#125;</span><br><span class="line">    \item 项</span><br><span class="line">    \item 项</span><br><span class="line">\end&#123;itemize&#125;</span><br></pre></td></tr></table></figure>
<p>例如，可以是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\begin&#123;frame&#125;&#123;快乐摸鱼&#125;</span><br><span class="line">    如何让自己的摸鱼更快乐呢？</span><br><span class="line">    \begin&#123;itemize&#125;</span><br><span class="line">        \item 第一个级别是接受摸鱼</span><br><span class="line">        \item 第二个级别是享受摸鱼</span><br><span class="line">        \item 第三个级别是高水平摸鱼，成为一名摸鱼大师</span><br><span class="line">    \end&#123;itemize&#125;</span><br><span class="line">\end&#123;frame&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\begin&#123;enumerate&#125;</span><br><span class="line">    \item 项</span><br><span class="line">    \item 项</span><br><span class="line">\end&#123;enumerate&#125;</span><br></pre></td></tr></table></figure>
<p>例如，可以是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\begin&#123;frame&#125;&#123;快乐摸鱼&#125;</span><br><span class="line">    如何让自己的摸鱼更快乐呢？</span><br><span class="line">    \begin&#123;enumerate&#125;</span><br><span class="line">        \item 接受摸鱼</span><br><span class="line">        \item 享受摸鱼</span><br><span class="line">        \item 高水平摸鱼，成为一名摸鱼大师</span><br><span class="line">    \end&#123;enumerate&#125;</span><br><span class="line">\end&#123;frame&#125;</span><br></pre></td></tr></table></figure>
<h4 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h4><h5 id="单张"><a href="#单张" class="headerlink" title="单张"></a>单张</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\begin&#123;figure&#125;</span><br><span class="line">    \centering</span><br><span class="line">    \includegraphics[width=0.8\linewidth]&#123;图片路径&#125; % width处可修改图片大小</span><br><span class="line">    \caption&#123;图注&#125;</span><br><span class="line">\end&#123;figure&#125;</span><br></pre></td></tr></table></figure>
<h5 id="并列"><a href="#并列" class="headerlink" title="并列"></a>并列</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\begin&#123;figure&#125;[htbp]</span><br><span class="line">    \centering</span><br><span class="line">    \begin&#123;minipage&#125;&#123;0.49\linewidth&#125; % 修改这里调整每行图片的数量</span><br><span class="line">        \centering</span><br><span class="line">        \includegraphics[width=0.6\linewidth]&#123;图片1路径&#125;</span><br><span class="line">        \caption&#123;图注1&#125;</span><br><span class="line">    \end&#123;minipage&#125;</span><br><span class="line">    %\qquad</span><br><span class="line">    \begin&#123;minipage&#125;&#123;0.49\linewidth&#125;</span><br><span class="line">        \centering</span><br><span class="line">        \includegraphics[width=0.6\linewidth]&#123;图片2路径&#125;</span><br><span class="line">        \caption&#123;图注2&#125;</span><br><span class="line">    \end&#123;minipage&#125;</span><br><span class="line">\end&#123;figure&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用过程中新手容易踩的坑"><a href="#使用过程中新手容易踩的坑" class="headerlink" title="使用过程中新手容易踩的坑"></a>使用过程中新手容易踩的坑</h2><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>如果编译不通过报错看不懂，而且定位在一些比较奇怪的地方，那么大概率是触发关键字了，包括但不限于”&amp;“等。可以二分检查一下报错的这一大段哪里出了问题，大概率能定位到某个你不知道它是关键字的关键字。</p>
<h3 id="引用需要多次编译"><a href="#引用需要多次编译" class="headerlink" title="引用需要多次编译"></a>引用需要多次编译</h3><p>这个问题不止在beamer里会出现，属于LaTeX通用问题了。如果发现图注数目、页数、目录或者引用失效了，请多编译几遍。猜测LaTeX的编译机制是一趟的，缺失的数据就瞎填或者用上次的，但是这次编译过程中会刷新数据，下次编译渲染出来的页面内容自然就是正确的了。</p>
<h1 id="修改模板配置文件，定制专属Beamer"><a href="#修改模板配置文件，定制专属Beamer" class="headerlink" title="修改模板配置文件，定制专属Beamer"></a>修改模板配置文件，定制专属Beamer</h1><p>本文基于<a href="https://github.com/tuna/THU-Beamer-Theme">清华开源Beamer模板</a>，对如何修改其配置文件使之适配自己需求进行介绍。具体修改实例见<a href="https://github.com/Olive-2019/JLU-THU-Beamer-Theme">该仓库</a>。</p>
<h2 id="主题颜色"><a href="#主题颜色" class="headerlink" title="主题颜色"></a>主题颜色</h2><p>主题颜色的修改在<a href="https://github.com/Olive-2019/JLU-THU-Beamer-Theme/blob/master/Tsinghua.sty">Tsinghua.sty</a>文件中，推荐使用VSCode打开修改，具有高亮等功能。当然，如果你想用记事本也没事，只是稍微有点难看而已。</p>
<h3 id="定义颜色"><a href="#定义颜色" class="headerlink" title="定义颜色"></a>定义颜色</h3><p>定义清华紫的颜色是这一行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\xdefinecolor&#123;tsinghua&#125;&#123;rgb&#125;&#123;0.455,0.204,0.506&#125;  %RGB#82318E</span><br></pre></td></tr></table></figure>

<p>仿照清华紫，我们可以定义吉大蓝，获取吉大蓝的方式是对校徽使用Windows自带的画图工具取色，获得其RGB值，然后得出定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\xdefinecolor&#123;jlu&#125;&#123;RGB&#125;&#123;20,71,166&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修改背景颜色"><a href="#修改背景颜色" class="headerlink" title="修改背景颜色"></a>修改背景颜色</h3><p>简单粗暴一些，将Tsinghua.sty文件中，除了定义以外的所有tsinghua都替换成你定义的颜色名字，如实例中的jlu</p>
<h2 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">% 首页</span><br><span class="line">\kaishu</span><br><span class="line">\begin&#123;frame&#125;</span><br><span class="line">    \titlepage</span><br><span class="line">    \begin&#123;figure&#125;[htpb]</span><br><span class="line">        \begin&#123;center&#125;</span><br><span class="line">            \includegraphics[width=0.2\linewidth]&#123;pic/Tsinghua_University_Logo.eps&#125;</span><br><span class="line">        \end&#123;center&#125;</span><br><span class="line">    \end&#123;figure&#125;</span><br><span class="line">\end&#123;frame&#125;</span><br></pre></td></tr></table></figure>

<p>在首页处将插入的图片换成自己想放的图（如自己学校校徽）</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\kaishu</span><br><span class="line">\begin&#123;frame&#125;</span><br><span class="line">    \titlepage</span><br><span class="line">    \begin&#123;figure&#125;[htpb]</span><br><span class="line">        \begin&#123;center&#125;</span><br><span class="line">            \includegraphics[width=0.2\linewidth]&#123;pic/jlu_logo.eps&#125;</span><br><span class="line">        \end&#123;center&#125;</span><br><span class="line">    \end&#123;figure&#125;</span><br><span class="line">\end&#123;frame&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修改字体"><a href="#修改字体" class="headerlink" title="修改字体"></a>修改字体</h2><p>如果想要使用更为学术的中文宋体英文times new roman风格，可以加上该配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\usepackage&#123;amsmath, fontspec&#125;</span><br><span class="line">\usefonttheme&#123;serif&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
        <tag>slide</tag>
      </tags>
  </entry>
  <entry>
    <title>AutoGenRS4LCDP</title>
    <url>/Olivia_Lam.github.io/2022/10/19/AutoGenRS4LCDP/</url>
    <content><![CDATA[<p>自动生成服务于LCDP的推荐系统</p>
<span id="more"></span>

<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><h2 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h2><p>2020年发了第一篇关于自动生成推荐系统集成到MDE中的文章，相对来说只是理论为主。</p>
<blockquote>
<p><em>Towards automating the construction of recommender systems for low-code development platforms</em></p>
</blockquote>
<p>2021年发了第二篇同一主题的文章，相比上一篇，似乎已经有了具体工具（没找到可运行版本，只有图片），也做了集成到eclipse以外平台的尝试（chatbot），但是似乎并没有真正用上NLP，还是以命令和选项的形式交互、</p>
<blockquote>
<p><em>Automating the Synthesis of Recommender Systems for Modelling Languages</em></p>
</blockquote>
<h2 id="人物机构"><a href="#人物机构" class="headerlink" title="人物机构"></a>人物机构</h2><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>RS在MDE中有重要的作用，但是RS的生成需要特殊的知识和时间，故设计一个通用的，能自动生成用于LCDP的RS。</p>
<h2 id="实施方案的技术路线"><a href="#实施方案的技术路线" class="headerlink" title="实施方案的技术路线"></a>实施方案的技术路线</h2><h3 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h3><p><img src="https://github.com/Olive-2019/Lam-Blog-resource/blob/master/images/AutoGenRS4LCDP/overview.jpg?raw=true" alt="overview" title="架构"></p>
<ol>
<li>RS设计师提供元模型</li>
<li>模型仓库（训练数据）</li>
<li>RS设计师使用DSL语言定义元模型的元素（包括user、item、item特征、推荐系统的配置）</li>
<li>框架为LCDP自动生成一个定制的推荐系统</li>
<li>开发者将会在LCDP中获得建议，形式包括图上的提示、实例碎片甚至是使用自然语言的交互机器人</li>
</ol>
<h3 id="流程架构"><a href="#流程架构" class="headerlink" title="流程架构"></a>流程架构</h3><p><img src="https://github.com/Olive-2019/Lam-Blog-resource/blob/master/images/AutoGenRS4LCDP/overview%20of%20process.jpg?raw=true" alt="overview of process" title="流程架构"><br>step1-2人工配置，step3-7自动生成</p>
<h4 id="通过DSL配置-step2"><a href="#通过DSL配置-step2" class="headerlink" title="通过DSL配置(step2)"></a>通过DSL配置(step2)</h4><p><img src="https://github.com/Olive-2019/Lam-Blog-resource/blob/master/images/AutoGenRS4LCDP/DSL%20meta-model.jpg?raw=true" alt="DSL meta-model" title="DSL 元模型"></p>
<p>包含推荐系统的创建方法、数据划分方法、评价方法等，以下为实例</p>
<p><img src="https://github.com/Olive-2019/Lam-Blog-resource/blob/master/images/AutoGenRS4LCDP/DSL.jpg?raw=true" alt="DSL example" title="DSL实例"></p>
<h4 id="数据准备-step3"><a href="#数据准备-step3" class="headerlink" title="数据准备(step3)"></a>数据准备(step3)</h4><p><img src="https://github.com/Olive-2019/Lam-Blog-resource/blob/master/images/AutoGenRS4LCDP/%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86.jpg?raw=true" alt="数据预处理" title="数据预处理"></p>
<p>数据准备步骤：</p>
<ol>
<li>获取模型</li>
<li>数据预处理（模型提取）</li>
<li>生成user-item矩阵和item-feature矩阵</li>
</ol>
<p><img src="https://github.com/Olive-2019/Lam-Blog-resource/blob/master/images/AutoGenRS4LCDP/%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E4%BE%8B%E5%AD%90.jpg?raw=true" alt="数据预处理实例" title="数据预处理实例"></p>
<ol>
<li>原始数据（模型）</li>
<li>提取user（各个类）</li>
<li>提取item（各个属性）</li>
<li>提取item的feature（各属性的名字和类型）</li>
<li>生成user-item矩阵</li>
<li>生成item-feature矩阵</li>
</ol>
<h4 id="推荐系统引擎-step3-4"><a href="#推荐系统引擎-step3-4" class="headerlink" title="推荐系统引擎(step3-4)"></a>推荐系统引擎(step3-4)</h4><p><img src="https://github.com/Olive-2019/Lam-Blog-resource/blob/master/images/AutoGenRS4LCDP/RS%E5%BC%95%E6%93%8E.jpg?raw=true" alt="推荐系统引擎" title="推荐系统引擎"></p>
<h5 id="数据集划分-2"><a href="#数据集划分-2" class="headerlink" title="数据集划分(2)"></a>数据集划分(2)</h5><p>根据DSL指定的比例划分训练集和测试集</p>
<h5 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h5><p>根据DSL配置(3)，使用训练集数据(4)训练推荐系统。</p>
<p>根据配置信息，训练的推荐系统可能有多个</p>
<h5 id="测试-5-7"><a href="#测试-5-7" class="headerlink" title="测试(5)(7)"></a>测试(5)(7)</h5><p>每一个备选推荐系统都在测试数据集上进行测试，得出一系列分数</p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><h3 id="有效性测试"><a href="#有效性测试" class="headerlink" title="有效性测试"></a>有效性测试</h3><p>概述20年文章的有效性测试，21年只是换了数据集，差别不大</p>
<h4 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h4><p><img src="https://github.com/Olive-2019/Lam-Blog-resource/blob/master/images/AutoGenRS4LCDP/%E6%95%B0%E6%8D%AE%E9%9B%86.jpg?raw=true" alt="数据集" title="数据集"><br>数据集有三个：</p>
<p>第一个是将互联网上找到的类图使用EMF转化为模型库中的标准模型，</p>
<p>第二个是第一个模型的扩展版，将第一个模型中的一些名词同义替代</p>
<p>第三个数据集是元模型（元模型也类似于类图）</p>
<h4 id="实验条件设置"><a href="#实验条件设置" class="headerlink" title="实验条件设置"></a>实验条件设置</h4><h5 id="推荐系统配置"><a href="#推荐系统配置" class="headerlink" title="推荐系统配置"></a>推荐系统配置</h5><p>前两个数据集与前面的DSL实例配置一样。由于第三个数据集是元模型，user和item略有不同，但大体类似</p>
<h5 id="数据集划分"><a href="#数据集划分" class="headerlink" title="数据集划分"></a>数据集划分</h5><p>训练集：测试集&#x3D;8：2</p>
<h5 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h5><p>十折交叉验证，求结果均值</p>
<h5 id="推荐系统方法"><a href="#推荐系统方法" class="headerlink" title="推荐系统方法"></a>推荐系统方法</h5><h6 id="协同过滤-collaborative-filtering"><a href="#协同过滤-collaborative-filtering" class="headerlink" title="协同过滤(collaborative filtering)"></a>协同过滤(collaborative filtering)</h6><p>基线方法：pop</p>
<p>基于user的：cfubk(k表示k近邻，例如k&#x3D;3时是cfub3)</p>
<p>基于item的：cfibk(同上)</p>
<h6 id="基于内容-content-based"><a href="#基于内容-content-based" class="headerlink" title="基于内容(content-based)"></a>基于内容(content-based)</h6><p>简写cb</p>
<h6 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h6><p>cbubk(同上)</p>
<h5 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h5><h6 id="精度precision"><a href="#精度precision" class="headerlink" title="精度precision"></a>精度precision</h6><p>推荐列表里相关的项目占比</p>
<h6 id="召回率recall"><a href="#召回率recall" class="headerlink" title="召回率recall"></a>召回率recall</h6><p>相关项目在推荐列表里的占比</p>
<h6 id="F1"><a href="#F1" class="headerlink" title="F1"></a>F1</h6><p>前两个指标的调和平均</p>
<h6 id="用户覆盖率USC"><a href="#用户覆盖率USC" class="headerlink" title="用户覆盖率USC"></a>用户覆盖率USC</h6><p>推荐系统可以服务的用户比例</p>
<h6 id="项目覆盖率ISC"><a href="#项目覆盖率ISC" class="headerlink" title="项目覆盖率ISC"></a>项目覆盖率ISC</h6><p>推荐系统可以推荐的项目占比</p>
<h6 id="归一化折损累计增益nDCG-Normalized-Discounted-Cumulative-Gain"><a href="#归一化折损累计增益nDCG-Normalized-Discounted-Cumulative-Gain" class="headerlink" title="归一化折损累计增益nDCG(Normalized Discounted Cumulative Gain)"></a>归一化折损累计增益nDCG(Normalized Discounted Cumulative Gain)</h6><p>衡量最相关的项目是否在推荐列表顶端</p>
<h4 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h4><p><img src="https://github.com/Olive-2019/Lam-Blog-resource/blob/master/images/AutoGenRS4LCDP/%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C.jpg?raw=true" alt="实验结果" title="实验结果"><br>可以看到，在AtlanEcore数据集上的表现更好，也许是因为该数据集规模较大（AtlanEcore数据集有300个模型，其它数据集只有29&#x2F;58个模型）</p>
<h5 id="研究目标"><a href="#研究目标" class="headerlink" title="研究目标"></a>研究目标</h5><h6 id="推荐系统可以帮助建模吗？"><a href="#推荐系统可以帮助建模吗？" class="headerlink" title="推荐系统可以帮助建模吗？"></a>推荐系统可以帮助建模吗？</h6><p>可以，AtlanEcore数据集在cfub2方法下F1达到了0.289，效果较好</p>
<h6 id="哪些推荐方法有最好的效果？"><a href="#哪些推荐方法有最好的效果？" class="headerlink" title="哪些推荐方法有最好的效果？"></a>哪些推荐方法有最好的效果？</h6><p>Synthetic数据集上，cbib方法最好（混合方法）</p>
<p>SyntheticExtended和AtlanEcore数据集上，cfub2方法最好（协同过滤）</p>
<h6 id="混合方法会更好吗？"><a href="#混合方法会更好吗？" class="headerlink" title="混合方法会更好吗？"></a>混合方法会更好吗？</h6><p>Synthetic数据集上混合方法表现更好，但是该数据集较小，不确定是否有关。</p>
<h6 id="在考虑到用户覆盖率和项目覆盖率时，什么方法更好？"><a href="#在考虑到用户覆盖率和项目覆盖率时，什么方法更好？" class="headerlink" title="在考虑到用户覆盖率和项目覆盖率时，什么方法更好？"></a>在考虑到用户覆盖率和项目覆盖率时，什么方法更好？</h6><p>通常来说，高用户覆盖率与低项目覆盖率并行，用户覆盖率较高的方法意味着较低的项目覆盖率</p>
<p>pop和cb方法的用户覆盖率高，而协同过滤方法的项目覆盖率较高</p>
<h3 id="平台集成测试：chatbot"><a href="#平台集成测试：chatbot" class="headerlink" title="平台集成测试：chatbot"></a>平台集成测试：chatbot</h3><p>这个测试在21年的论文中才有，主要目的是看RS集成到其它较复杂的平台时的困难<br><img src="https://github.com/Olive-2019/Lam-Blog-resource/blob/master/images/AutoGenRS4LCDP/architecture%20of%20integration.jpg?raw=true" alt="集成架构" title="集成架构"><br>前端包含推荐系统命令和交互平台，后端包括推荐系统handler和转换器</p>
<h4 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h4><p><img src="https://github.com/Olive-2019/Lam-Blog-resource/blob/master/images/AutoGenRS4LCDP/%E6%95%88%E6%9E%9C%E5%9B%BE.jpg?raw=true" alt="效果图" title="效果图"></p>
<p><img src="https://github.com/Olive-2019/Lam-Blog-resource/blob/master/images/AutoGenRS4LCDP/%E6%95%88%E6%9E%9C%E5%9B%BE2.jpg?raw=true" alt="效果图" title="效果图"></p>
<h4 id="代码量"><a href="#代码量" class="headerlink" title="代码量"></a>代码量</h4><p><img src="https://github.com/Olive-2019/Lam-Blog-resource/blob/master/images/AutoGenRS4LCDP/LOC.jpg?raw=true" alt="LOC" title="LOC"></p>
<p>可以看到代码主要集中在前端，且代码量都不大</p>
<h2 id="论文优势"><a href="#论文优势" class="headerlink" title="论文优势"></a>论文优势</h2><p>架构较为清晰</p>
<p>实验设置明确，可复现性高</p>
<h2 id="论文局限性"><a href="#论文局限性" class="headerlink" title="论文局限性"></a>论文局限性</h2><p>无落地实例，甚至实验都是一个小的模块</p>
<p>所谓的NLP颇有挂羊头卖狗肉嫌疑，目前虽然有集成到chatbot里的例子，但只是在生成类的时候使用到了自然语言，如果想要使用推荐系统，还是需要使用命令和选项交互的形式。</p>
<h1 id="启发"><a href="#启发" class="headerlink" title="启发"></a>启发</h1><h2 id="在DWF中的使用"><a href="#在DWF中的使用" class="headerlink" title="在DWF中的使用"></a>在DWF中的使用</h2><p>定制表单模型或者应用模型时，可以给出一定的建议</p>
<h2 id="构建难度"><a href="#构建难度" class="headerlink" title="构建难度"></a>构建难度</h2><h3 id="开发难度"><a href="#开发难度" class="headerlink" title="开发难度"></a>开发难度</h3><p>文章给的架构比较清晰，代码量应该不大</p>
<h3 id="数据困境"><a href="#数据困境" class="headerlink" title="数据困境"></a>数据困境</h3><p>首先是用户，由于DWF是面向企业的，用户量相对较小，且用户之间的关联度较低</p>
<p>其次是数据量，与上一个原因类似，对于某一个用户来说真正有效的可能只有自己的历史数据，而这个数据量并不大，故训练起推荐系统来可能较为困难</p>
<h3 id="应用困境"><a href="#应用困境" class="headerlink" title="应用困境"></a>应用困境</h3><p>目前不知道推荐系统对于DWF模型这种数据集是否有效，如果要开发应用的话，最好先做在数据集上推荐系统的裸实验。</p>
]]></content>
      <categories>
        <category>论文阅读笔记</category>
      </categories>
      <tags>
        <tag>RS</tag>
        <tag>lowcomote</tag>
        <tag>MDE</tag>
        <tag>chatbot</tag>
        <tag>NLP</tag>
        <tag>LCDP</tag>
      </tags>
  </entry>
  <entry>
    <title>一些小工具</title>
    <url>/Olivia_Lam.github.io/2022/10/13/tool/</url>
    <content><![CDATA[<p>实用小工具</p>
<span id="more"></span>

<h1 id="吉大邮箱"><a href="#吉大邮箱" class="headerlink" title="吉大邮箱"></a>吉大邮箱</h1><p>吉大邮箱没有提供提醒工具，时时查网页版邮箱不太方便，此处提供两种提醒解决方案。</p>
<h2 id="自动转发"><a href="#自动转发" class="headerlink" title="自动转发"></a>自动转发</h2><p>QQ邮箱的提醒非常好用，包括但不限于QQ（电脑端登录QQ有弹窗）和微信（手机端巨好使）的提醒，所以可以将吉大邮箱的邮件转发到QQ邮箱。同理，可以转发到任意你觉得好用的邮箱中。</p>
<p>设置路径如下：</p>
<p>设置-&gt;邮件收发-&gt;自动转发-&gt;选择自动转发-&gt;“转发到邮箱”中填写QQ邮箱</p>
<h2 id="Windows版邮件"><a href="#Windows版邮件" class="headerlink" title="Windows版邮件"></a>Windows版邮件</h2><p>直接绑定就好了，感觉速度比转发的提醒慢一点。电脑端的提醒弹窗比QQ的好看一点，而且任务栏里会有提醒。</p>
<h1 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h1><h2 id="SwitchHosts"><a href="#SwitchHosts" class="headerlink" title="SwitchHosts"></a>SwitchHosts</h2><p>众所周知，GitHub在国内无法长期稳定有效地访问，原因是DNS污染，GitHub服务器IP在国内并未封禁，故可通过改host文件的方式访问GitHub。但长期手动修改hosts太麻烦了，购买梯子又太贵了（价格敏感性消费者.jpg），所以找到了这个自动修改hosts的神器。</p>
<h3 id="使用指南"><a href="#使用指南" class="headerlink" title="使用指南"></a>使用指南</h3><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p><a href="https://github.com/oldj/SwitchHosts/releases">下载地址（release版）</a>选择自己OS对应的版本，如Windows选择<a href="https://github.com/oldj/SwitchHosts/releases/download/v4.1.2/SwitchHosts_windows_installer_4.1.2.6086.exe">SwitchHosts_windows_installer_4.1.2.6086.exe</a>。</p>
<h4 id="连接远程hosts"><a href="#连接远程hosts" class="headerlink" title="连接远程hosts"></a>连接远程hosts</h4><ol>
<li>点击加号添加hosts</li>
<li>选择远程hosts类型</li>
<li>标题随意取</li>
<li>URL填 <strong><a href="https://raw.hellogithub.com/hosts">https://raw.hellogithub.com/hosts</a></strong></li>
<li>设置自动刷新频率（建议1h）</li>
<li>点击确定</li>
</ol>
<h4 id="修改hosts文件属性"><a href="#修改hosts文件属性" class="headerlink" title="修改hosts文件属性"></a>修改hosts文件属性</h4><p>好了，现在大概率会发现无法写入host文件，解决方案如下：</p>
<ol>
<li>找到hosts文件，Windows下路径C:\Windows\System32\drivers\etc\</li>
<li>右键，选择属性，取消“只读”选项</li>
<li>在属性中选中“安全”tab</li>
<li>选中User</li>
<li>点击编辑</li>
<li>选中“写入”“修改”等权限</li>
<li>保存</li>
</ol>
<h3 id="使用评价"><a href="#使用评价" class="headerlink" title="使用评价"></a>使用评价</h3><p>目前GitHub访问体验完全无痛，不用再担心push的时候老半天push不上去。而且比梯子强的是，这玩意只在访问GitHub的时候重定向了IP地址，访问国内其它网站不会发生绕来绕去过慢的现象。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>A Model-Driven Engineering Approach for Monitoring Machine Learning Models</title>
    <url>/Olivia_Lam.github.io/2022/10/11/MDEforMLMonitor/</url>
    <content><![CDATA[<p>机器学习监控的软件工程方法</p>
<p>机器学习模型部署后需要监控，但是机器学习领域专家缺乏相关知识去完成一个健壮且可扩展的监控解决方案。本文基于MDE提出了一个用于检测和响应影响ML模型性能变化的方案，允许ML专家在计算集群上调度漂移检测算法，并通过email接收通知</p>
<span id="more"></span>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>文章主要做了两件事：</p>
<ul>
<li>提出针对ML模型监测的MDE方法</li>
<li>评估这种方法怎么降低ML专家设计ML监测系统时技术障碍</li>
</ul>
<h1 id="机器学习监控领域介绍"><a href="#机器学习监控领域介绍" class="headerlink" title="机器学习监控领域介绍"></a>机器学习监控领域介绍</h1><p>有监督学习中的X，Y通常被视为服从联合概率分布P(X, Y)的随机变量。由于真实世界情况复杂且不稳定，概率分布会发生变化，即概念漂移、采样漂移、先验概率漂移或更一般的数据集漂移。</p>
<p>在非稳定情况下进行机器学习的方法：</p>
<ol>
<li>测试集中X的边缘概率分布调整模型</li>
<li>因果模型中，根据测试集中样本标签是否可知，存在大量的对抗漂移的技术</li>
<li>在线学习。算法不预先假设分布，接收样本的时候持续训练<br>适用场景：预计环境会随时间推移而改变<br>缺点：需要恒定的带标记数据流</li>
<li>混合方法。模型使用初始数据集训练也会在一批带标记数据可用时重新调整<br>例如，使用模型集对抗漂移，最新的被标记数据集可用时，将会训练一个新的模型，并加入到模型集中。然后算法将会检车模型集的性能是否一致，根据结果对模型集中的权重进行调整</li>
</ol>
<h1 id="元模型"><a href="#元模型" class="headerlink" title="元模型"></a>元模型</h1><h2 id="为什么需要元模型"><a href="#为什么需要元模型" class="headerlink" title="为什么需要元模型"></a>为什么需要元模型</h2><p>即使已经有很多解决非稳定环境中的机器学习困境的方法，机器学习模型部署仍然需要满足非功能需求，如延迟、计算存储资源、和现有配置的兼容性等。同时，ML模型设计人和系统设计人不一定是同一个人，对于部署模型来说也是一大难题。故需要使用MDE方法解决这个问题。</p>
<h2 id="DSL"><a href="#DSL" class="headerlink" title="DSL"></a>DSL</h2><p>使用MDE实现和部署ML模型的一个重要组成部分是DSL。DSL能在负责ML算法专家和负责具体系统的软件工程师之间建立标准化的通信层。<br>我们对DSL的期望是</p>
<ul>
<li>尽可能多地表达不同类型的ML监控方法</li>
<li>尽可能少地约束底层技术</li>
</ul>
<h2 id="ML模型部署环境假设"><a href="#ML模型部署环境假设" class="headerlink" title="ML模型部署环境假设"></a>ML模型部署环境假设</h2><ul>
<li>ML模型持续接收未标记的样本（推理请求），并需要返回一个预测结果（推理响应）</li>
<li>未标记样本可能在未知时长后接收到真实标签</li>
<li>定期根据ML模型接收到的最新数据决定是否修正模型</li>
<li>由领域专家定义不同种类的漂移响应策略</li>
</ul>
<h2 id="元模型组成部件"><a href="#元模型组成部件" class="headerlink" title="元模型组成部件"></a>元模型组成部件</h2><p>考虑到上述假设，提出的元模型需要有这些组成部件。</p>
<ul>
<li>指定想要监控哪一个ML模型的机制</li>
<li>指定哪些推理请求和推理响应字段需要被捕捉。（这也是在命名被捕捉字段的方法。命名可以方便其它实体单独引用它。）</li>
<li>定义周期性漂移检测执行机制</li>
<li>定义检测到漂移时，需要采取的措施</li>
</ul>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>虽然希望元模型和具体底层技术完全分离，但为尽快从算法专家处得到反馈，这个版本的元模型做了一些妥协。下文将会提及这些妥协。</p>
<p><img src="https://github.com/Olive-2019/Lam-Blog-resource/blob/master/images/MDEforMLMonitor/domain_meta-model.jpg?raw=true" alt="domain_meta-model"></p>
<h3 id="Deployment类"><a href="#Deployment类" class="headerlink" title="Deployment类"></a>Deployment类</h3><p>deployment抽象类包括了ML监控方法的所有方面。在系统中，通常有一个Model子类的实例和任意数量的DriftDetector子类的实例。</p>
<h3 id="Model类"><a href="#Model类" class="headerlink" title="Model类"></a>Model类</h3><p>Model类包含了名称、序列化ML模型的URL、创建它的框架名称、多个输入的IO实例和一个输出的IO实例。</p>
<p><strong>妥协</strong>：为了简化展示，ML模型将会被部署到web端点。因此需要序列化ML模型的URL、创建它的框架名称这两个属性，这两个属性并不需要被包含进来，因为部署过程可能是单独执行的。</p>
<h3 id="IO类"><a href="#IO类" class="headerlink" title="IO类"></a>IO类</h3><p>模型的输入输出，包含输入&#x2F;输出的名字和数据类型的枚举属性。</p>
<h3 id="DriftDetector类"><a href="#DriftDetector类" class="headerlink" title="DriftDetector类"></a>DriftDetector类</h3><p>周期性地执行漂移检测算法，属性包含名字、频率、email、定制容器。</p>
<p>执行的算法可以有以下两种可能</p>
<ul>
<li>底层平台包含的算法中选择一种</li>
<li>自定义算法</li>
</ul>
<p><strong>妥协</strong>：区分两种漂移检测器。区分是为了简化底层技术实现。<br><strong>妥协</strong>：属性中包含了email，检测到模型漂移的行为只能是发送email了。（可以抽象化成一个超类）</p>
<h4 id="DataDriftDetector类"><a href="#DataDriftDetector类" class="headerlink" title="DataDriftDetector类"></a>DataDriftDetector类</h4><p>数据漂移检测器需要一组带标签的训练数据和一组不带标签的数据。</p>
<h4 id="ConceptDriftDetector类"><a href="#ConceptDriftDetector类" class="headerlink" title="ConceptDriftDetector类"></a>ConceptDriftDetector类</h4><p>概念漂移检测器需要不带标签数据的预测数据。</p>
<h1 id="生成的工件"><a href="#生成的工件" class="headerlink" title="生成的工件"></a>生成的工件</h1><p>使用M2T转化语言，生成一个Kubernetes清单，清单包含需要预分配的资源和需要在集群上运行的容器化应用程序。</p>
<p>组件包含两种类型</p>
<ul>
<li>开源的定制的Kubernetes资源</li>
<li>容器注册表中著猜测的容器化的应用。</li>
</ul>
<p>优点</p>
<ul>
<li>没有生成过程代码</li>
</ul>
<p>生成工件如下所述：</p>
<p><img src="https://github.com/Olive-2019/Lam-Blog-resource/blob/master/images/MDEforMLMonitor/generated_artifacts.jpg?raw=true" alt="生成的工件"></p>
<h2 id="Inference-Service-推理服务"><a href="#Inference-Service-推理服务" class="headerlink" title="Inference Service 推理服务"></a>Inference Service 推理服务</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>该组件包括两个功能，分别是Model Server和Logger。</p>
<h4 id="Model-Server模型服务器"><a href="#Model-Server模型服务器" class="headerlink" title="Model Server模型服务器"></a>Model Server模型服务器</h4><p>负责响应各种应用程序发送的推理请求</p>
<h4 id="Logger-记录者"><a href="#Logger-记录者" class="headerlink" title="Logger 记录者"></a>Logger 记录者</h4><p>负责记录请求和响应事件</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>由Kubeflow开源项目的Inference Service定制生成。</p>
<h2 id="Message-Queue-消息队列"><a href="#Message-Queue-消息队列" class="headerlink" title="Message Queue 消息队列"></a>Message Queue 消息队列</h2><h3 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h3><p>从Logger接收消息，路由至Database Writer</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>Knative开源项目的Broker和Trigger定制生成</p>
<h2 id="Database-Writer-数据库写者"><a href="#Database-Writer-数据库写者" class="headerlink" title="Database Writer 数据库写者"></a>Database Writer 数据库写者</h2><h3 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h3><ul>
<li>根据算法专家提供的消息初始化数据库</li>
<li>将捕获到的数据存储到数据库中</li>
</ul>
<p>捕获的数据来源</p>
<ul>
<li>logger记录的事件。由于格式是已知的，可以根据算法专家的说明提取特征值</li>
<li>ML模型性能反馈。指之前推理请求数据的真实标签</li>
</ul>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>Knative开源项目中的Service定制生成。</p>
<h2 id="Database-数据库"><a href="#Database-数据库" class="headerlink" title="Database 数据库"></a>Database 数据库</h2><p>该组件使用MySQL数据库，由Kubernete的基础API和MySQL官方容器映像提供的Deployment、Service、PersistentVolumeClaim实现。</p>
<h2 id="Drift-Detection-Execution-漂移检测执行器"><a href="#Drift-Detection-Execution-漂移检测执行器" class="headerlink" title="Drift Detection Execution 漂移检测执行器"></a>Drift Detection Execution 漂移检测执行器</h2><h3 id="功能-3"><a href="#功能-3" class="headerlink" title="功能"></a>功能</h3><p>该组件周期性执行算法专家指定的漂移检测算法。</p>
<p>算法专家可以只实现漂移检测算法，并指定实现这个算法的容器映像，不必实现数据检索和通知发送的部分。</p>
<h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><p>由Kubernete基础API提供的CronJob资源提供服务。</p>
<p>在该实现中，应用程序的功能包括</p>
<ul>
<li>获取数据。从数据库中获取测试集数据，从云存储库中获取训练集数据</li>
<li>检测。传递给实现漂移检测算法的函数，并获取返回</li>
<li>警报。根据返回决定是否要发送警报</li>
</ul>
<h2 id="Configuration-配置"><a href="#Configuration-配置" class="headerlink" title="Configuration 配置"></a>Configuration 配置</h2><h3 id="功能-4"><a href="#功能-4" class="headerlink" title="功能"></a>功能</h3><p>通过使用配置文件，容器化应用程序根据算法专家规定的需求调整自己的功能。</p>
<h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><p>使用Kubernete的基础API的ConfigMaps实现。</p>
<h2 id="Proxy-代理"><a href="#Proxy-代理" class="headerlink" title="Proxy 代理"></a>Proxy 代理</h2><h3 id="功能-5"><a href="#功能-5" class="headerlink" title="功能"></a>功能</h3><p>需要用同一个主机名接收推理请求和反馈数据，所以需要使用代理来进行转发。代理接收请求后根据请求路径转发到inference service或database writer。</p>
<h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><p>使用Istio开源项目的VirtualService定制</p>
<h1 id="平台"><a href="#平台" class="headerlink" title="平台"></a>平台</h1><p>为了最大程度地降低算法专家的使用门槛，建立了web应用</p>
<h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><p>创作和提交MDE模型</p>
<ol>
<li>用户填写表单，包含元模型各个类的属性</li>
<li>M2T生成Kubernetes清单</li>
<li>Kubernetes清单用作Kubernetes的CLI工具的输入</li>
<li>CLI工具将Kubernetes清单中指定的对象发送到集群的API服务器</li>
<li>形成ML监控系统的部署</li>
</ol>
<h2 id="辅助功能"><a href="#辅助功能" class="headerlink" title="辅助功能"></a>辅助功能</h2><ul>
<li>列出当前监控的所有ML模型，每个模型包含两个URL，一个用于发送推理请求，另一个用于发送反馈数据</li>
<li>提供表单，将序列化的ML模型上传到云端</li>
<li>提供表单，将数据集上传到云端</li>
<li>用户可以Python函数形式自定义漂移检测算法。用户自定义的代码将与漂移检测器的基本模板结合，构建容器映像，并注册到注册表上。</li>
</ul>
<h1 id="Future-Works-拓展工作"><a href="#Future-Works-拓展工作" class="headerlink" title="Future Works 拓展工作"></a>Future Works 拓展工作</h1><h2 id="工作方向"><a href="#工作方向" class="headerlink" title="工作方向"></a>工作方向</h2><ul>
<li><p>漂移检测的时机：目前定时，将来可以定量</p>
</li>
<li><p>足够抽象的漂移检测算法类：目前为了方便底层实现，分成了DataDraft和ConceptDraft两个类</p>
</li>
<li><p>漂移发生时的行为：目前是发邮件，可以在元模型中抽象成超类</p>
</li>
<li><p>差分部署：希望修改某些部分的时候不必完全重新部署</p>
</li>
</ul>
<h2 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h2><ul>
<li>是否足够通用</li>
<li>是否减轻了ML模型监控所需的工作</li>
</ul>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>lowcomote</tag>
        <tag>ML monitor</tag>
      </tags>
  </entry>
  <entry>
    <title>Towards automating the construction of recommender systems for low-code development platforms</title>
    <url>/Olivia_Lam.github.io/2022/10/08/RS3/</url>
    <content><![CDATA[<p>用于低代码开发平台的推荐系统</p>
<span id="more"></span>

<h1 id="4个问题"><a href="#4个问题" class="headerlink" title="4个问题"></a>4个问题</h1><ol>
<li>推荐系统可以帮助类建模吗？</li>
<li>哪一种推荐方法在相关属性、方法、超类的推荐上性能最好？</li>
<li>混合方法会更好吗？</li>
<li>考虑用户覆盖率和项目覆盖率时，哪一种方法会更好？</li>
</ol>
<h1 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h1><p>在使用低代码开发平台开发应用时，需要推荐系统推荐一些工件，如类中的属性和方法。</p>
<h1 id="方法概述"><a href="#方法概述" class="headerlink" title="方法概述"></a>方法概述</h1><p><img src="https://github.com/Olive-2019/Lam-s-Blog-source/blob/master/RS3/1665226767819.png?raw=true" alt="架构"></p>
<p>推荐系统设计者使用DSL定义元模型（1），假设存在模型库（2）用于推荐。生成一个定制的推荐系统，嵌入到低代码开发平台之中，向开发者提供建议。</p>
<h1 id="提出的方法"><a href="#提出的方法" class="headerlink" title="提出的方法"></a>提出的方法</h1><p><img src="https://github.com/Olive-2019/Lam-s-Blog-source/blob/master/RS3/1665227277118.png?raw=true" alt="1665227277118"></p>
<p>设计者只需要完成前两布，即数据收集和使用DSL配置推荐系统。第三步到第七步都是自动完成的</p>
<h2 id="DSL配置"><a href="#DSL配置" class="headerlink" title="DSL配置"></a>DSL配置</h2><p>跟之前那篇一样</p>
<h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>流程：</p>
<ol>
<li>获取模型</li>
<li>提取与配置的用户、项目、项目特征类型对应的模型对象</li>
<li>生成用户-项目和项目-特征矩阵</li>
</ol>
<p>例子：</p>
<p><img src="https://github.com/Olive-2019/Lam-s-Blog-source/blob/master/RS3/1665245563318.png?raw=true"></p>
<p>（1）获取模型</p>
<p>（2）提取所有的用户（3）提取所有项目的名字（4）提取项目特征</p>
<p>（5）（6）两个矩阵</p>
<h2 id="推荐系统引擎"><a href="#推荐系统引擎" class="headerlink" title="推荐系统引擎"></a>推荐系统引擎</h2><p>对应图4的步骤4-7，包括数据切割、推荐系统生成、训练、评价和部署。<br><img src="https://github.com/Olive-2019/Lam-s-Blog-source/blob/master/RS3/1665246085399.png?raw=true"></p>
<p>每一个候选推荐系统被评价都会有一个分数，设计者可以看到这个分数。</p>
<p>我们希望能够自动生成一个最佳配置的推荐系统。</p>
<h1 id="实验验证"><a href="#实验验证" class="headerlink" title="实验验证"></a>实验验证</h1><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p><img src="https://github.com/Olive-2019/Lam-s-Blog-source/blob/master/RS3/1665332963070.png?raw=true" alt="1665332963070"></p>
<p>三个数据集，前两个是人工构造的（后一个是前一个变换来的），最后一个是真实数据</p>
<h2 id="实验设计"><a href="#实验设计" class="headerlink" title="实验设计"></a>实验设计</h2><h3 id="数据分割"><a href="#数据分割" class="headerlink" title="数据分割"></a>数据分割</h3><p>十重交叉验证、8：2分层抽样（每个类的80%项目用于训练）划分训练集和测试集</p>
<h3 id="推荐方法"><a href="#推荐方法" class="headerlink" title="推荐方法"></a>推荐方法</h3><p>协同过滤、基于内容、混合</p>
<h3 id="评估指标"><a href="#评估指标" class="headerlink" title="评估指标"></a>评估指标</h3><p>精度（相关的推荐项目的百分比）、召回率（推荐列表中包含相关项目的百分比）、F1、覆盖率（用户空间覆盖率、项目空间覆盖率）、标准化折扣累计收益（nDCG，最相关的项目在不在列表顶部）</p>
<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="https://github.com/Olive-2019/Lam-s-Blog-source/blob/master/RS3/1665332667791.png?raw=true" alt="1665332667791"></p>
<p>AtlanEcore数据集上性能较好，估计是数据集较大的缘故</p>
<p>回答四个问题</p>
<h3 id="推荐系统可以帮助类建模吗？"><a href="#推荐系统可以帮助类建模吗？" class="headerlink" title="推荐系统可以帮助类建模吗？"></a>推荐系统可以帮助类建模吗？</h3><p>所有方法在所有数据集上精度都在0.2-0.3之间，但是论文里说F1到达0.28+，就可以用了</p>
<h3 id="哪一种推荐方法在相关属性、方法、超类的推荐上性能最好？"><a href="#哪一种推荐方法在相关属性、方法、超类的推荐上性能最好？" class="headerlink" title="哪一种推荐方法在相关属性、方法、超类的推荐上性能最好？"></a>哪一种推荐方法在相关属性、方法、超类的推荐上性能最好？</h3><p>不同的数据集上最佳方法不同</p>
<h3 id="混合方法会更好吗？"><a href="#混合方法会更好吗？" class="headerlink" title="混合方法会更好吗？"></a>混合方法会更好吗？</h3><p>在Synthetic数据集上混合方法表现更好</p>
<h3 id="考虑用户覆盖率和项目覆盖率时，哪一种方法会更好？"><a href="#考虑用户覆盖率和项目覆盖率时，哪一种方法会更好？" class="headerlink" title="考虑用户覆盖率和项目覆盖率时，哪一种方法会更好？"></a>考虑用户覆盖率和项目覆盖率时，哪一种方法会更好？</h3><p>精度和召回率低的混合方法给出了高用户覆盖率和低项目覆盖率。用户覆盖率需要以项目覆盖率为代价</p>
<h2 id="实验结果有效性的威胁"><a href="#实验结果有效性的威胁" class="headerlink" title="实验结果有效性的威胁"></a>实验结果有效性的威胁</h2><h3 id="内部威胁"><a href="#内部威胁" class="headerlink" title="内部威胁"></a>内部威胁</h3><p>研究和结论之间的相关性。由于数据集是人工创建的，而且数据量小，可能存在引入误差的问题。所以存在AtlanEcore数据集。</p>
<h3 id="外部威胁"><a href="#外部威胁" class="headerlink" title="外部威胁"></a>外部威胁</h3><p>模型的推广性。实验是面向具体任务和语言的，将来可能用于其它任务、以及其它数据集。</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>RS</tag>
        <tag>lowcomote</tag>
      </tags>
  </entry>
  <entry>
    <title>Recommender Systems in Model-Driven Engineering</title>
    <url>/Olivia_Lam.github.io/2022/10/05/Engineering/</url>
    <content><![CDATA[<p>推荐系统在软件建模中的作用的综述，应该不是我们关注的重点</p>
<span id="more"></span>

<h1 id="三个问题"><a href="#三个问题" class="headerlink" title="三个问题"></a>三个问题</h1><ol>
<li>推荐系统在软件建模中起什么作用？<br>通常用于完成和修复工件。<br>通常是独立于语言的，特定的一般针对UML或过程建模符号</li>
<li>哪些推荐技术用于支持软件建模？评价方法？<br>基于内容&gt;基于知识<br>评价方法：离线</li>
<li>推荐系统还有什么可做的？<br>几乎没有用于模型转化或代码生成的推荐系统，很少推荐系统用于创建、重用、查找工件。此外，还有有效的软件建模的工件库、协同过滤利用群体知识、基于用户的推荐系统评估、与低代码平台的有效寄成机制</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>RS</tag>
        <tag>lowcomote</tag>
      </tags>
  </entry>
  <entry>
    <title>Automating the Synthesis of Recommender Systems for Modelling Languages</title>
    <url>/Olivia_Lam.github.io/2022/10/01/RS/</url>
    <content><![CDATA[<p>低代码开发推荐系统</p>
<span id="more"></span>

<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>希望能使用推荐系统建模，但是推荐系统的开发存在需要难以考虑的问题和专业知识，所以提出了一个针对软件模型的<strong>推荐系统自动生成工具</strong>。为评估该系统，实验测试了一个生成的推荐系统和聊天程序建模。</p>
<h1 id="RS-推荐系统"><a href="#RS-推荐系统" class="headerlink" title="RS 推荐系统"></a>RS 推荐系统</h1><p>推荐系统的目标用户是生成的且偏好是有特殊含义的。例如，用户可能是一个未完成的类，需要被推荐方法和成员变量。</p>
<p>推荐系统的两种信息源：<strong>基于内容</strong>（Content-based CB）、<strong>协同过滤</strong>（collaborative filtering CF）。基于内容评估用户历史数据，协同过滤评估用户相似性。此外，协同过滤可以评估用户或项目之间的相似性。典型的混合策略是使用CB的相似性代替CF的评级。</p>
<p>推荐系统评价方法：<strong>在线</strong>、<strong>离线</strong>。在线方法使用在线A&#x2F;B测试实时获取影响，离线方法使用历史数据，分为训练集和测试集。</p>
<p>常用评价指标：<strong>精度</strong>、（precision）、<strong>召回率</strong>（recall）、<strong>F1</strong>、<strong>平均精度</strong>（MAP）、<strong>归一化累积好处</strong>（nDCG，评估最有用的项目是否出现在推荐列表的顶部位置）</p>
<p>补充评价指标：<strong>用户空间覆盖</strong>（USC，评估覆盖了多少用户）、<strong>项目空间覆盖</strong>（ISC，评估覆盖了多少项目）</p>
<p>提出的自动生成推荐系统允许配置这几个方面的参数：<strong>推荐方法、目标用户、项目、离线评价方法和指标</strong></p>
<h1 id="提出的方法"><a href="#提出的方法" class="headerlink" title="提出的方法"></a>提出的方法</h1><p><img src="https://github.com/Olive-2019/Lam-s-Blog-source/blob/master/RS/1665226282989.png?raw=true" alt="1665226282989"></p>
<p><strong>流程：</strong></p>
<ol>
<li>选择推荐系统需要推荐的元素，如类的属性，过程的任务。指定推荐方法、训练数据集、推荐系统指标</li>
<li>推荐系统训练过程</li>
<li>选择推荐方法，系统自动生成可以集成到不同建模工具里的推荐系统</li>
</ol>
<h1 id="Droid-DSL（一种领域特定语言）"><a href="#Droid-DSL（一种领域特定语言）" class="headerlink" title="Droid DSL（一种领域特定语言）"></a>Droid DSL（一种领域特定语言）</h1><p>用来描述提出的自动生成推荐系统的一种语言</p>
<h1 id="架构与支撑工具"><a href="#架构与支撑工具" class="headerlink" title="架构与支撑工具"></a>架构与支撑工具</h1><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>该系统的架构由三个模块组成，分别是配置器、服务、客户。</p>
<p>第一个模块是<strong>配置器</strong>，该模块提供了配置、评估、生成推荐系统的功能。同时也提供了一个eclipse编辑器用于指定推荐系统内容（1）。该内容作为推荐系统评价系统的输入。推荐系统评价系统依赖于RankSys和RiVal，其中RankSys是实现推荐系统的框架，RiVal是一个数据划分和推荐系统评价的工具集。每一个指标都会显示在Eclipse的视图里（3）。根据得到的指标，推荐系统设计人员可以选择一种推荐方法并生成一系列配置文件。</p>
<p>第二个模块是DROID<strong>服务</strong>，该模块使用了第一个模块生成的配置文件。通过4模块生成不同的配置文件可以适配不同的建模语言。</p>
<p>第三个模块是<strong>客户</strong>，这个系统允许客户使用基于JSON的模型表示发送请求。</p>
<h2 id="支撑工具"><a href="#支撑工具" class="headerlink" title="支撑工具"></a>支撑工具</h2><p>配置器部分的工具是eclipse的一个插件，支持使用DSL配置、查看指标结果。</p>
<p>服务方面采用方式是，客户端提交JSON格式的请求，服务端处理并返回推荐系统名字和JSON格式的推荐系统。服务主要包含三个模块，推荐器（用于处理客户端请求）、内容解析（用于解析JSON文件）、推荐系统生成器</p>
<h1 id="自己的一点碎碎念"><a href="#自己的一点碎碎念" class="headerlink" title="自己的一点碎碎念"></a>自己的一点碎碎念</h1><p>其实就是一个支持用户定制推荐系统的低代码开发平台，但是跟清华数为的项目有些差异。这里还需要使用一些类似yml的DSL书写配置，不是完全的图形化界面。</p>
<p>从文章看来，工具应该是已经开发完可以用的了，文章中也给了链接，但是还没真正安装试试。</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>RS</tag>
        <tag>lowcomote</tag>
      </tags>
  </entry>
</search>
